### 18 | 宏任务和微任务：不是所有任务都是一个待遇

## 宏任务
    消息队列中的任务
- WHATWG 规范定义的大致流程:
    1. 先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；
    2. 然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；
    3. 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；
    4. 最后统计执行完成的时长等信息。

## 微任务
- 异步回调：
    - 第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。
    - 第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。
**微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。**

- 当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个**微任务队列**。
    微任务队列是给 V8 引擎内部使用的，所以无法通过 JavaScript 直接访问的。

- 产生微任务有两种方式：
    1. 使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。
    2. 使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。

- 在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。**WHATWG 把执行微任务的时间点称为检查点。**

- 结论：
    1. 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
    2. 微任务的执行时长会影响到当前宏任务的时长。
    3. 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。

# 监听 DOM 变化方法演变
Web 应用需要*监视 DOM 变化并及时地做出响应*。
- 2000 年的时候引入了 Mutation Event，Mutation Event 采用了**观察者的设计模式**，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。
- 从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。
    MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，**一次触发异步调用**，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。
MutationObserver 采用了**异步 + 微任务**的策略。