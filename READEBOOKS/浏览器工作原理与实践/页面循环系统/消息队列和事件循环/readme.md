### 15 | 消息队列和事件循环：页面是怎么“活”起来的？

# 在线程运行过程中处理新任务
  **要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。**

# 处理其他线程发送过来的任务
  **消息队列**一种数据结构，可以存放要执行的任务。
    要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。
    
# 处理其他进程发送过来的任务
  **渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息**，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面讲解的“处理其他线程发送的任务”一样

# 消息队列中的任务类型
  - 内部消息类型， 如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。
  - 页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。

# 如何安全退出
  页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。

# 页面使用单线程的缺点
- 第一个问题是如何处理高优先级的任务。
    如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的*执行效率*；如果采用异步方式，又会影响到*监控的实时性*。
    - 解决： 
        1. 把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，也就解决了执行效率的问题。
        2. 宏任务中的主要功能都直接完成之后，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样就解决了实时性问题。

- 第二个是如何解决单个任务执行时长过久的问题。
    - 解决：
        JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。