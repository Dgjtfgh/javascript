### 13 | 垃圾回收：垃圾数据是如何自动回收的？

有些数据被使用之后，可能就不再需要了，我们把这种数据称为**垃圾数据**。

## 不同语言的垃圾回收策略
  **手动回收** 何时分配内存、何时销毁内存都是由代码控制的  如 C/C++ 
  **自动回收** 产生的垃圾数据是由垃圾回收器来释放的  如 JavaScript、Java、Python 等语言

## 调用栈中的数据是如何回收的
```js
function foo(){
    var a = 1
    var b = {name:" 极客邦 "}
    function showName(){
      var c = " 极客时间 "
      var d = {name:" 极客时间 "}
    }
    showName()
}
foo()
```
图 *执行到 showName 函数时的内存模型.png*
- 如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。
- 当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，**这个下移操作就是销毁 showName 函数执行上下文的过程**。

结论：当一个函数执行结束之后，**JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文**。

## 堆中的数据是如何回收的

# 代际假说和分代收集
- 代际假说  特点：
    1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
    2. 不死的对象，会活得更久。

- 在 V8 中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象**。
    1. 副垃圾回收器，主要负责新生代的垃圾回收。
    2. 主垃圾回收器，主要负责老生代的垃圾回收。

# 垃圾回收器的工作流程
  1. 标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
  2. 回收非活动对象所占据的内存。
  3. 做内存整理。
    频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为*内存碎片*。

- 副垃圾回收器
    主要负责新生区的垃圾回收。通常情况下，大多数小的对象都会被分配到新生区。区域不大，垃圾回收比较频繁。
    **Scavenge 算法**
    1. 把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。
    2. 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。
    3. 对对象区域中的垃圾做标记。
    4. 副垃圾回收器会把这些存活的对象复制到空闲区域中，并把这些对象有序地排列起来。
    5. 对象区域与空闲区域进行角色翻转。
    6. JavaScript 引擎采用了对象**晋升策略**，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。
- 复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以**为了执行效率，一般新生区的空间会被设置得比较小。**
- 新生区的空间不大，所以很容易被存活的对象装满整个区域。所以JavaScript 引擎采用了对象**晋升策略**。

- 主垃圾回收器
    主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。
    - 特点：对象占用空间大，对象存活时间长。
    **标记 - 清除（Mark-Sweep）算法**
    1. 标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素就可以判断为**垃圾数据**。
    2. 垃圾的清除过程。 图 *主垃圾回收器标记清除过程.png*
    3. 产生大量不连续的内存碎片, **标记 - 整理（Mark-Compact）**  图 *主垃圾回收器标记整理过程.png*
        标记过程
        所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

# 全停顿
    由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为叫做全停顿（Stop-The-World）。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记（Incremental Marking）算法**。
如图： *增量标记.png*
    *把一个完整的垃圾回收任务拆分为很多小的任务,穿插在其他的 JavaScript 任务中间执行*
